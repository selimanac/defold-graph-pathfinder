local node_positions = {
	{ x = 100, y = 550 },
	{ x = 710, y = 550 },
	{ x = 100, y = 270 },
	{ x = 100, y = 100 },
	{ x = 275, y = 270 },
	{ x = 275, y = 455 },
	{ x = 405, y = 360 },
	{ x = 538, y = 360 },
	{ x = 580, y = 455 },
	{ x = 800, y = 550 },
	{ x = 450, y = 100 },
	{ x = 450, y = 160 },
	{ x = 625, y = 100 },
	{ x = 800, y = 100 },
	{ x = 800, y = 160 },
	{ x = 625, y = 160 },
	{ x = 538, y = 160 },
	{ x = 538, y = 215 },
	{ x = 625, y = 215 },
	{ x = 625, y = 270 },
	{ x = 800, y = 270 }
}

local nodes = {}
local edges = {
	{ from_node_id = 0,  to_node_id = 1,  bidirectional = true },
	{ from_node_id = 0,  to_node_id = 2,  bidirectional = true },
	{ from_node_id = 2,  to_node_id = 3,  bidirectional = true },
	{ from_node_id = 2,  to_node_id = 4,  bidirectional = true },
	{ from_node_id = 4,  to_node_id = 5,  bidirectional = true },
	{ from_node_id = 5,  to_node_id = 8,  bidirectional = true },
	{ from_node_id = 7,  to_node_id = 6,  bidirectional = true },
	{ from_node_id = 8,  to_node_id = 19, bidirectional = true },
	{ from_node_id = 4,  to_node_id = 11, bidirectional = true },
	{ from_node_id = 3,  to_node_id = 9,  bidirectional = false },
	{ from_node_id = 3,  to_node_id = 10, bidirectional = true },
	{ from_node_id = 10, to_node_id = 11, bidirectional = true },
	{ from_node_id = 11, to_node_id = 16, bidirectional = true },
	{ from_node_id = 10, to_node_id = 12, bidirectional = true },
	{ from_node_id = 12, to_node_id = 15, bidirectional = true },
	{ from_node_id = 12, to_node_id = 13, bidirectional = true },
	{ from_node_id = 13, to_node_id = 14, bidirectional = true },
	{ from_node_id = 16, to_node_id = 15, bidirectional = true },
	{ from_node_id = 15, to_node_id = 14, bidirectional = true },
	{ from_node_id = 16, to_node_id = 17, bidirectional = true },
	{ from_node_id = 15, to_node_id = 18, bidirectional = true },
	{ from_node_id = 17, to_node_id = 18, bidirectional = true },
	{ from_node_id = 14, to_node_id = 20, bidirectional = false },
	{ from_node_id = 18, to_node_id = 19, bidirectional = true },
	{ from_node_id = 19, to_node_id = 20, bidirectional = true },
	{ from_node_id = 20, to_node_id = 9,  bidirectional = true }
}

local nodes_go = {}

-- Path
local path_size = 0
local path_status = 0
local path_status_text = ""
local path = {}


local smoothed_path_size = 0
local smoothed_path = {}

-- Path Projected
local projected_path_size = 0
local projected_path_status = 0
local projected_path_status_text = ""
local projected_path = {}
local projected_path_entry_point = vmath.vector3()

local start_id = 0
local goal_id = 13
local max_path = 128


local mouse_position = vmath.vector3()

local function draw_nodes()
	for i, node in ipairs(node_positions) do
		local node_id = factory.create("/factories#node", vmath.vector3(node.x, node.y, 0))

		local u = msg.url(node_id)
		u.fragment = "node_id"

		label.set_text(u, i - 1)

		table.insert(nodes_go, node_id)
	end
end

local function draw_edge(from, to, bidirectional, is_init)
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(0, 1, 0, 1) })

	if not bidirectional and is_init then
		local center = (from + to) * 0.5

		local dir = to - from
		local angle = math.atan2(dir.y, dir.x)

		factory.create("/factories#direction", center, vmath.quat_rotation_z(angle - math.pi * 0.5))
	end
end

local function draw_edges(is_init)
	is_init = is_init or false

	for i, edge in ipairs(edges) do
		local from_v2 = node_positions[edge.from_node_id + 1]
		local from = vmath.vector3(from_v2.x, from_v2.y, 0)

		local to_v2 = node_positions[edge.to_node_id + 1]
		local to = vmath.vector3(to_v2.x, to_v2.y, 0)

		draw_edge(from, to, edge.bidirectional, is_init)
	end
end


local function draw_static_smoothed_path()
	for i = 1, smoothed_path_size - 1, 1 do
		local from_node = smoothed_path[i]
		local to_node = smoothed_path[i + 1]

		msg.post("@render:", "draw_line", { start_point = vmath.vector3(from_node.x, from_node.y, 0), end_point = vmath.vector3(to_node.x, to_node.y, 0), color = vmath.vector4(1, 0, 0, 1) })
	end
end

local function draw_static_path()
	for i = 1, path_size - 1, 1 do
		local from_node = path[i]
		local to_node = path[i + 1]

		msg.post("@render:", "draw_line", { start_point = vmath.vector3(from_node.x, from_node.y, 0), end_point = vmath.vector3(to_node.x, to_node.y, 0), color = vmath.vector4(1, 0, 0, 1) })
	end
end

local function draw_projected_path()
	msg.post("@render:", "draw_line", { start_point = mouse_position, end_point = projected_path_entry_point, color = vmath.vector4(1, 0, 0, 1) })

	local first_node = projected_path[1]

	msg.post("@render:", "draw_line", { start_point = projected_path_entry_point, end_point = vmath.vector3(first_node.x, first_node.y, 0), color = vmath.vector4(1, 0, 0, 1) })

	for i = 1, projected_path_size - 1, 1 do
		local from_node = projected_path[i]
		local to_node = projected_path[i + 1]

		msg.post("@render:", "draw_line", { start_point = vmath.vector3(from_node.x, from_node.y, 0), end_point = vmath.vector3(to_node.x, to_node.y, 0), color = vmath.vector4(1, 0, 0, 1) })
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	profiler.enable_ui(true)
	profiler.set_ui_view_mode(profiler.VIEW_MODE_MINIMIZED)

	pathfinder.init(100, 10, 4, 32, 32)

	nodes = pathfinder.add_nodes(node_positions)


	local go_url = msg.url("/node_1")
	local node_id = pathfinder.add_gameobject_node(go_url)

	pathfinder.add_edges(edges)


	local smooting_config = {
		style                               = pathfinder.PathSmoothStyle.BEZIER_QUADRATIC,
		bezier_sample_segment               = 8,
		bezier_control_point_ooffset        = 0.4, -- bezier_cubic
		bezier_curve_radius                 = 0.8, -- bezier_quadratic
		bezier_adaptive_tightness           = 0.5, -- bezier_adaptive
		bezier_adaptive_roundness           = 0.5, -- bezier_adaptive
		bezier_adaptive_max_corner_distance = 50.0, -- bezier_adaptive
		bezier_arc_radius                   = 60.0 -- circular_arc
	}

	local path_smoothing_id = pathfinder.add_path_smoothing(smooting_config)
	print("path_smoothing_id", path_smoothing_id)

	local smooting_config = {
		style                               = pathfinder.PathSmoothStyle.BEZIER_QUADRATIC,
		bezier_sample_segment               = 6,
		bezier_control_point_ooffset        = 0.4, -- bezier_cubic
		bezier_curve_radius                 = 0.8, -- bezier_quadratic
		bezier_adaptive_tightness           = 0.5, -- bezier_adaptive
		bezier_adaptive_roundness           = 0.5, -- bezier_adaptive
		bezier_adaptive_max_corner_distance = 50.0, -- bezier_adaptive
		bezier_arc_radius                   = 60.0 -- circular_arc
	}

	path_smoothing_id = pathfinder.add_path_smoothing(smooting_config)
	print("path_smoothing_id", path_smoothing_id)

	-- ========================
	--FIND PATH
	-- ========================
	path_size, path_status, path_status_text, path = pathfinder.find_path(start_id, goal_id, max_path)

	pprint("-> " .. path_status_text)
	if path_status == pathfinder.PathStatus.SUCCESS then
		--	pprint(path_size, path_status, path)
	end

	smoothed_path_size, smoothed_path = pathfinder.smooth_path(2, path)

	draw_nodes()
	draw_edges(true)
end

local y = 120
local speed = 160 -- units per second
local dir = 1     -- 1 = up, -1 = down
local min_y = 100
local max_y = 150


function update(self, dt)
	draw_static_path()
	draw_static_smoothed_path()

	-- Move up or down
	y = y + speed * dir * dt

	-- Reverse when reaching limits
	if y > max_y then
		y = max_y
		dir = -1
	elseif y < min_y then
		y = min_y
		dir = 1
	end

	pathfinder.move_node(2, y, 270)
	node_positions[3].x = y
	node_positions[3].y = 270
	go.set_position(vmath.vector3(y, 270, 0), nodes_go[3])


	draw_edges()


	-- ========================
	-- PROJECTED PATH
	-- ========================
	projected_path_size, projected_path_status, projected_path_status_text, projected_path_entry_point, projected_path = pathfinder.find_projected_path(mouse_position.x, mouse_position.y, goal_id, max_path, 2)

	--	pprint("-> " .. projected_path_status_text)
	go.set_position(projected_path_entry_point, "/entry")
	if projected_path_status == pathfinder.PathStatus.SUCCESS then
		--	pprint(projected_path_size, projected_path_status, projected_path_entry_point, projected_path)
		draw_projected_path()
	end
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	mouse_position.x = action.x
	mouse_position.y = action.y
	go.set_position(mouse_position, "/mouse")
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
