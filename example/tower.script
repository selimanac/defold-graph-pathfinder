local nodes = {}
local edges = {}
-- Path
local path_size = 0
local path_status = 0
local path_status_text = ""
local path = {}


local smoothed_path_size = 0
local smoothed_path = {}

-- Path Projected
local projected_path_size = 0
local projected_path_status = 0
local projected_path_status_text = ""
local projected_path = {}
local projected_path_entry_point = vmath.vector3()

local start_id = 0
local goal_id = 13
local max_path = 128

local node_positions = {
	{ x = 1710,   y = 310 },
	{ x = 1480,   y = 310 },
	{ x = 1480,   y = 1040 },
	{ x = 1330,   y = 310 },
	{ x = 1180,   y = 310 },
	{ x = 1180,   y = 440 },
	{ x = 1180,   y = 720 },
	{ x = 1180,   y = 840 },
	{ x = 1043.8, y = 840 },
	{ x = 780,    y = 840 },
	{ x = 650,    y = 840 },
	{ x = 650,    y = 660 },
	{ x = 530,    y = 540 },
	{ x = 360,    y = 540 },
	{ x = 360,    y = 400 },
	{ x = 360,    y = 250 },
	{ x = 530.7,  y = 250 },
	{ x = 680,    y = 80 },
}


local smooting_config = {
	style                               = pathfinder.PathSmoothStyle.CIRCULAR_ARC,
	bezier_sample_segment               = 8,
	bezier_control_point_offset         = 0.4, -- bezier_cubic
	bezier_curve_radius                 = 0.8, -- bezier_quadratic
	bezier_adaptive_tightness           = 0.5, -- bezier_adaptive
	bezier_adaptive_roundness           = 0.5, -- bezier_adaptive
	bezier_adaptive_max_corner_distance = 50.0, -- bezier_adaptive
	bezier_arc_radius                   = 80.0 -- circular_arc
}

local function add_nodes()
	for i, node_id in ipairs(nodes) do
		local pos_v2 = pathfinder.get_node_position(node_id)
		local node_url = factory.create("/factories#node", vmath.vector3(pos_v2.x, pos_v2.y, 0))
		node_url = msg.url(node_url)
		node_url.fragment = "node_id"

		label.set_text(node_url, node_id)
	end
end

local function draw_edge(from, to, bidirectional, is_init)
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(0, 1, 0, 1) })

	if bidirectional == false and is_init then
		local center = (from + to) * 0.5

		local dir = to - from
		local angle = math.atan2(dir.y, dir.x)

		factory.create("/factories#direction", center, vmath.quat_rotation_z(angle - math.pi * 0.5))
	end
end

local function draw_edges(is_init)
	is_init = is_init or false

	for i, edge in ipairs(edges) do
		local from_v2 = pathfinder.get_node_position(edge.from_node_id)
		local from = vmath.vector3(from_v2.x, from_v2.y, 0)
		local to_v2 = pathfinder.get_node_position(edge.to_node_id)
		local to = vmath.vector3(to_v2.x, to_v2.y, 0)

		draw_edge(from, to, edge.bidirectional, is_init)
	end
end

local function load_data()
	local edges_json, error = sys.load_resource("/data/toweredges.json")
	if error then
		print(error)
		return
	end
	local nodes_json, error = sys.load_resource("/data/towernodes.json")

	if error then
		print(error)
		return
	end

	local nodes_data = node_positions --json.decode(nodes_json)
	edges = json.decode(edges_json)

	nodes = pathfinder.add_nodes(nodes_data)
	pathfinder.add_edges(edges)

	add_nodes()
	draw_edges(true)
end



local function draw_path(path_size, path)
	for i = 1, path_size - 1, 1 do
		local from_node = path[i]
		local to_node = path[i + 1]

		msg.post("@render:", "draw_line", { start_point = vmath.vector3(from_node.x, from_node.y, 0), end_point = vmath.vector3(to_node.x, to_node.y, 0), color = vmath.vector4(1, 1, 0, 1) })
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	profiler.enable_ui(true)
	profiler.set_ui_view_mode(profiler.VIEW_MODE_MINIMIZED)

	pathfinder.init(18, nil, 4, 32, 256)

	load_data()

	local path_smoothing_id = pathfinder.add_path_smoothing(smooting_config)
	path_size, path_status, path_status_text, path = pathfinder.find_path(0, 16, 32, path_smoothing_id)

	pprint("-> " .. path_status_text)
	if path_status == pathfinder.PathStatus.SUCCESS then
		--	pprint(path_size, path_status, path)
	end
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	--	draw_edges()

	draw_path(path_size, path)
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
